(ns structure-interpretation-cp.chapter-4.3
  (:require [structure-interpretation-cp.chapter-4.1
             :refer [application? apply-primitive-procedure assignment-value
                     assignment-variable assignment? compound-procedure?
                     create-mapping define-variable! definition-value definition-variable definition?
                     extend-environment if-alternative if-consequent if-predicate if? lambda-body
                     lambda-parameters lambda? lookup-variable-value make-procedure operands operator
                     primitive-procedure? procedure-body procedure-env procedure-parameters quoted?
                     read-lines-till-empty self-evaluating? set-variable-value! tagged-list?
                     text-of-quotation the-global-environment user-print variable?]]
            [structure-interpretation-cp.chapter-4.parse :as parse]))

;; 4.3 Variations on a Scheme — Nondeterministic Computing

(declare amb)
(declare analyze)

(defn require-amb [p] (when (not p) (amb)))

(defn an-element-of [items]
  (require-amb (not (empty items)))
  (amb (first items) (an-element-of (rest items))))

(defn an-integer-starting-from [n]
  (amb n (an-integer-starting-from (inc n))))



;; Structure of the evaluator

;; Simple expressions
;; The execution procedures for the simplest kinds of expressions are 
;; essentially the same as those for the ordinary evaluator, except for the
;; need to manage the continuations. The execution procedures simply
;; succeed with the value of the expression, passing along the failure
;; continuation that was passed to them.
(defn- analyze-self-evaluating [exp]
  (fn [env succeed fail] (succeed exp fail)))

(defn- analyze-quoted [exp]
  (let [qval (text-of-quotation exp)]
    (fn [env succeed fail] (succeed qval fail))))

(defn- analyze-variable [exp]
  (fn [env succeed fail] (succeed (lookup-variable-value exp env) fail)))

(defn- analyze-lambda [exp]
  (let [vars (lambda-parameters exp)
        ;; differs from book which uses analyze-sequence
        bproc (analyze (lambda-body exp))]
    (fn [env succeed fail] (succeed (make-procedure vars bproc env) fail))))

;; Conditionals and sequences
;; Conditionals are also handled in a similar way as in the ordinary evaluator. 
;; The execution procedure generated by analyze-if invokes the
;; predicate execution procedure pproc with a success continuation that
;; checks whether the predicate value is true and goes on to execute either the 
;; consequent or the alternative. If the execution of pproc fails,
;; the original failure continuation for the if expression is called.
(defn- analyze-if [exp]
  (let [pproc (analyze (if-predicate exp))
        cproc (analyze (if-consequent exp))
        aproc (analyze (if-alternative exp))]
    (fn [env succeed fail]
      (pproc env
             (fn [pred-value fail2]
               (if (true? pred-value)
                 (cproc env succeed fail2)
                 (aproc env succeed fail2)))
             fail))))

;; Definitions and assignments

;; Definitions are another case where we must go to some trouble to manage 
;; the continuations, because it is necessary to evaluate the definition
;; value expression before actually defining the new variable. 
;; To accomplish this, the definition-value execution procedure vproc is called with
;; the environment, a success continuation, and the failure continuation.
;; If the execution of vproc succeeds, obtaining a value val for the defined
;; variable, the variable is defined and the success is propagated.
(defn- analyze-definition [exp]
  (let [var (definition-variable exp)
        vproc (analyze (definition-value exp))]
    (fn [env succeed fail]
      (vproc env
             (fn [val fail2]
               (define-variable! var val env)
               (succeed :ok fail2))
             fail))))

;; Assignments are more interesting. This is the first place where we really
;; use the continuations, rather than just passing them around. 
;; The execution procedure for assignments starts out like the one for definitions.
;; It first aempts to obtain the new value to be assigned to the variable.
;; If this evaluation of vproc fails, the assignment fails.
;; If vproc succeeds, however, and we go on to make the assignment,
;; we must consider the possibility that this branch of the computation
;; might later fail, which will require us to backtrack out of the assignment. 
;; Thus, we must arrange to undo the assignment as part of the
;; backtracking process.

;; This is accomplished by giving vproc a success continuation 
;; (marked with the comment “*1*” below) that saves the old value of the variable
;; before assigning the new value to the variable and proceeding from the
;; assignment. The failure continuation that is passed along with the value
;; of the assignment (marked with the comment “*2*” below) restores the
;; old value of the variable before continuing the failure. 
;; That is, a successful assignment provides a failure continuation 
;; that will intercept a
;; subsequent failure; whatever failure would otherwise have called fail2
;; calls this procedure instead, to undo the assignment before actually calling fail2.
(defn- analyze-assignment [exp]
  (let [var (assignment-variable exp)
        vproc (analyze (assignment-value exp))]
    (fn [env succeed fail]
      (vproc env
             (fn [val fail2] ; *1*
               (let [old-value (lookup-variable-value var env)]
                 (set-variable-value! var val env)
                 (succeed :ok
                          (fn [] ; *2*
                            (set-variable-value! var old-value env)
                            (fail2)))))
             fail))))

;; Procedure applications
;; The execution procedure for applications contains no new ideas except
;; for the technical complexity of managing the continuations. 
;; This complexity arises in analyze-application, due to the need to keep track of
;; the success and failure continuations as we evaluate the operands. We
;; use a procedure get-args to evaluate the list of operands, rather than
;; a simple map as in the ordinary evaluator.
(declare get-args)
(declare execute-application)
(defn- analyze-application [exp]
  (let [fproc (analyze (operator exp))
        aprocs (map analyze (operands exp))]
    (fn [env succeed fail]
      (fproc env
             (fn [proc fail2]
               (get-args aprocs
                         env
                         (fn [args fail3]
                           (execute-application
                            proc args succeed fail3))
                         fail2))
             fail))))

;; In get-args, notice how cdr-ing down the list of aproc execution procedures 
;; and consing up the resulting list of args is accomplished by
;; calling each aproc in the list with a success continuation that recursively 
;; calls get-args. Each of these recursive calls to get-args has a
;; success continuation whose value is the cons of the newly obtained 
;; argument onto the list of accumulated arguments
(defn get-args [aprocs env succeed fail]
  (if (empty? aprocs)
    (succeed '() fail)
    ((first aprocs)
     env
     ;; success continuation for this aproc
     (fn [arg fail2]
       (get-args
        (rest aprocs)
        env
        ;; success continuations for
        ;; recursive call to get-args
        (fn [args fail3]
          (succeed (cons arg args) fail3))
        fail2))
     fail)))

;; The actual procedure application, which is performed by execute-application, 
;; is accomplished in the same way as for the ordinary evaluator,
;; except for the need to manage the continuations.
(defn- execute-application [proc args succeed fail]
  (cond (primitive-procedure? proc)
        (succeed (apply-primitive-procedure proc args)
                 fail)
        (compound-procedure? proc)
        ((procedure-body proc)
         (extend-environment
          (create-mapping (procedure-parameters proc)
                          args)
          (procedure-env proc))
         succeed
         fail)
        :else
        (throw (RuntimeException.
                (str "Unknown procedure type: EXECUTE-APPLICATRION " proc)))))

;; Evaluating amb expressions
;; The amb special form is the key element in the nondeterministic language. 
;; Here we see the essence of the interpretation process and the
;; reason for keeping track of the continuations. The execution procedure
;; for amb defines a loop try-next that cycles through the execution 
;; procedures for all the possible values of the amb expression. Each execution
;; procedure is called with a failure continuation that will try the next one.
;; When there are no more alternatives to try, the entire amb expression
;; fails.
(defn amb? [exp] (tagged-list? exp :amb))
(defn amb-choices [exp] (rest exp))
(defn- analyze-amb [exp]
  (let [cprocs (map analyze (amb-choices exp))]
    (fn [env succeed fail]
      (letfn [(try-next [choices]
                (if (empty? choices)
                  (fail)
                  ((first choices)
                   env
                   succeed
                   (fn []
                     (try-next (rest choices))))))]
        (try-next cprocs)))))

(defn analyze [exp]
  (cond (self-evaluating? exp) (analyze-self-evaluating exp)
        (quoted? exp) (analyze-quoted exp)
        ;; added for section 4.3
        (amb? exp) (analyze-amb exp)

        (variable? exp) (analyze-variable exp)
        (assignment? exp) (analyze-assignment exp)
        (definition? exp) (analyze-definition exp)
        (if? exp) (analyze-if exp)
        (lambda? exp) (analyze-lambda exp)
        (application? exp) (analyze-application exp)
        :else (throw (RuntimeException. (str "Unknown expression type: ANALYZE" exp)))))


(defn ambeval [exp env succeed fail]
  ((analyze exp) env succeed fail))


(def input-prompt ";;; Amb-Eval input:")
(def output-prompt ";;; Amb-Eval value:")

(defn driver-loop []
  (letfn [(internal-loop [try-again]
            (let [input (parse/parse (read-lines-till-empty))]
              (println input)
              (if (= input :try-again)
                (try-again)
                (do
                  (println ";;;; Starting a new problem")
                  (ambeval
                   input
                   the-global-environment
                                ;; ambeval success
                   (fn [val next-alternative]
                     (println output-prompt)
                     (user-print val)
                     (internal-loop next-alternative))
                                ;; ambeval failure
                   (fn []
                     (println ";;; There are no more values of")
                     (user-print input)
                     (driver-loop)))))))]
    (internal-loop
     (fn []
       (println ";;;; There is no current problem")
       (driver-loop)))))


(ambeval (list :amb 1 2)
         the-global-environment
         (fn [val next-alt] (println val next-alt))
         (fn [] (println "FAIL")))

(ambeval 1
         the-global-environment
         (fn [val next-alt] (println val next-alt))
         (fn [] (println "FAIL")))

(driver-loop)

(comment
  (list (amb 1 2 3) (amb 'a 'b))

  (list 1 2 3)

  (define (require p) (if (not p) (amb) (list)))

  (define (an-element-of items)
    (require (not (null? items)))
    (amb (car items) (an-element-of (cdr items))))

  (define l (list 1 2 3))

  (an-element-of l)

  (define (same-pair list1 list2)
    (let ((a (an-element-of list1))
          (b (an-element-of list2)))
      (require (prime? (+ a b)))
      (list a b)))


  try-again

  try-again


  (define (an-integer-starting-from n)
    (amb n (an-integer-starting-from (+ n 1))))

  (an-integer-starting-from 0)

  ;
  )